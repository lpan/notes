e.g.
* `a + b * c - d`
* `(a + b) * (c - d)`

* In general, regular languages are insufficient for nested structures
  * eg. Expressions, blocks, loops, functions
  * DFA has finite number of states -> have to remember how many open brackets

* Therefore, we need something more powerful than regular languages (context
  free languages!)
  * Replace `iterations` / `repetitions` with `recursions`.
    * expr = ID | expr op expr | ( expr )
    * op = + | - | * | /


```
             ------------>   expr
            /                 |   \
 ----->   expr  <--           |    |
|          |       \          |    |
|         expr      \         |    |
|        / |   \     \        |    |
|       /  |    \     \       |    |
|      /   |     \     \      |    |
|    expr  op    expr   |     op   expr
|    |     |     |      |     |    |
|    ID    |     ID     |     |    ID
(    a     +     b      )     *    c
```

* Internal nodes ~ grammar rules


### Definition
A `context free grammar` is a 4-tuple `V, Sigma, P, S` where
  * V is a finite set of non-terminal symbols.
    - `{ expr, op }`
  * Sigma is a finite set (alphabet) terminal symbols
    - `{ ID, +, -, *, /, (, ) }`
  * P is a finite set of production rules
    - `{ expr -> ID, expr -> expr op expr, expr -> ( expr ), op -> +, op -> - }`
  * s is the start of non-terminal
    - `S <- V` (s is an element of V)
    - s is always the root of the parse tree
    - `S = expr`

### Conventions
  * Lowercase letters as terminal symbols
    - `a, b, c, d <- Sigma`
  * Uppercase letters as non-terminal variables
    - `A, B, C, D, S <- V`
  * `w, x, y, z` can be either terminal or non-terminal
    - `w, x, y, z <- Sigma*` (sequence of terminals)
    - `w, x, y, z <- (Sigma UNION V)*` (sequence of non-terminals and terminals)

### Definition
Alpha A Beta `directly derives` Alpha Delta Beta if A -> Delta -> P
  * expr => expr op expr => ID op expr

Alpha1 `derives` AlphaN if Alpha1 => Alpha2 => .... => AlphaN
  * expr => ID + ID


### Definition
* The language generated by grammar, G = ( V, Sigma, P, S ) is:
  * `{ w <- Sigma* | S => *w }`

* A language L is `context-free` if there exists a grammar G that generates L

* A `context-free grammar` is `ambiguous` if it allows **multiple** parse trees
  for same input strings
  * To specify language precisely, we need an unambiguous grammar.
  * Theorem: "there is no algorithm to determine if a grammar is ambiguous or not"
    * Find a string for the grammar to generate two parse trees to prove its
      ambiguity
* Unambiguous:
  * expr -> term | expr + term | expor - term
  * term -> ID | term * ID | term / ID
  * Enforce precedence / associativity rules / .. in grammar

* Parsing:
  * input: Grammar `G`, string `w`
  * output:
    - Boolean (does `S =>* w`?)
    - (Alternatively) generate derivation / parse tree
  * define function `parse(Alpha, x) = ` (does `Alpha =>* x`)
